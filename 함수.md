## 함수 이해하기
[`함수객체`](https://meetup.toast.com/posts/118), [`함수호출`](https://meetup.toast.com/posts/123)  

### 함수 선언식과 함수 표현식
함수 선언식의 경우 반드시 함수명이 정의 되어 있어야 한다.  
함수명을 정의한 함수 표현식을 `기명 함수 표현식`, 정의하지 않은 것을 `익명함수 표현식`이라고 한다. 
```javascript 
// 함수 선언식 
function a() { console.log('a'); } 

// 함수 표현식 - 익명 함수 표현식
let b = function () { console.log('b'); }

// 함수 표현식 - 기명 함수 표현식
let c = fucntion d () {console.log('c,b')}
```

### closure 클로져 
함수와 함수가 선언된 어휘적 환경(LexicalEnvironment)의 조합이다.  
앞서 설명한 실행 컨텍스트에서 배운 `어휘적 환경(LexicalEnvironment)` 의 의미를 정확히 알았다면  
클로저 이해하기가 어렵지 않다. `어휘적 환경(LexicalEnvironment)`은 이전 컨텍스트 객체의 정보를 가리키고 있다.
따라서 이전 컨텍스트에서 정의된 변수에 접근이 가능하게 된다.  
```javascript
function outer() {
  function inner(){
    console.log(a);
  }
  var a = 1;
  inner();
}
outer(); 
```
위의 코드의 실행 결과로 undefined가 아닌 1을 출력하게 된다.  
왜냐하면 closure가 이전 컨텍스트의 변수 a를 참조했기 때문이다.  
위에서 아래로의 코드가 익숙한 우리에게는 참 낯설게 느껴질수있다. 

## this 
js에서의 this는 어디서든 사용될수 있기에 많은 혼동을 가져왔다.  
크롬 개발자 도구(F12)에서 this를 입력해보자. window객체가 나오게 되는데.  
이유를 알아보자. 먼저 js에서 `this는 실행 컨텍스트가 생성 될때 함께 결정`된다. 
크롭 개발자 도구(F12)에서 this를 입력 할 때 전역 실행 컨텍스트가 생성되면서 전역 객체를 바라보게된다.

> 브라우저에서의 전역 객체는 `window`  
Node.js에서의 전역 객체는 `global` 

### 함수  this - window 객체

this는 실행 컨텍스트가 생성 될때 함께 결정된다고 배웠다. 

```javascript
var outer = function () {
    var inner = function() {    
        console.log('inner' + this);
    }
    console.log('outer' + this);
    inner();
} 
outer();

코드를 실행하면 어떤 결과 값이 나올지 추측해보자.  
1. 먼저 전역 컨텍스트가 생성이되고 outer()함수를 실행한다.  
2. outer() 실행 컨텍스트가 생성되면서 this는 outer함수를 바인딩 한다?
  → 53 번째줄 console 실행 : outer f outer
3. inner() 실행 컨텍스트가 생성되고 this는 inner함수를 바인딩 한다? 
  → 51 번째줄 console 실행 : inner f inner
  
하지만 실재로는 아래와 같이 동작한다.
1. 먼저 전역 컨텍스트가 생성이되고 outer()함수를 실행한다.  
2. outer() 실행 컨텍스트가 생성되면서 this는 window 를 바인딩 한다.
  → 53 번째줄 console 실행 : outer object window
3. inner() 실행 컨텍스트가 생성되고 this는 window 를 바인딩 한다.  
  → 51 번째줄 console 실행 : inner object window
```

그러나 실제로 실행해보면 결과값으로 window 객체가 나온다.😂   
놀라지 말자 js 전문가 `Douglas Crockford`는 이를 명백한 설계상의 오류라고 설명한다.  
이러한 오류로 인해 `this`가 여렵게 느껴질 수 있다. 하지만 이렇게 정리해보자  
**함수에서 `this` 는 전역객체 `widnow`를 가리킨다**

### 메서드 내부에서의 this - 호출한 주체의 정보

앞서 함수에서의 `this`는 전역객체를 `window`를 가리킨다고 배웠다. 
그러나 나는 은연중에 this를 사용한적이 있었는데, window 객체가 아닌 호출한 주체의 정보를 가지고 사용했던 경험이 있다.  
그 이유와 결론을 먼저 설명하자면, 메서드로 호출할 경우 this에는 `호출한 주체의 정보`가 담기게 된다.  

```javascript 
var object = {
    outer : function() {
        var inner = function(){
            console.log('inner' + this);
        }
        console.log('outer' + this);
        inner();
    }
}

object.outer();

결과값을 에측해보자ㅎㅎ

결과값을 확인해보자 
1. 먼저 전역 컨텍스트가 생성이되고 object 객체를 생성한다. 
  → 12 번째줄object객체의 메서드 outer() 실행 
2. outer() 실행 컨텍스트가 생성되면서 this는 호출한 주체인 object 를 바인딩 한다.
  → 6 번째줄 console 실행 : outer object object
3. inner() 실행 컨텍스트가 생성되고 this는 window 를 바인딩 한다.  
  → 4 번째줄 console 실행 : inner object window
```

메서드 내부에서 동작한 outer의 this는 호출한 주체인 object를 바인딩 했다.  
이에 반한 함수로서 동작한 inner의 this는 앞서 설명한 window를 바인딩 했다.  


### 생성자 내부에서의 this 

```javascript 
class dataModel {
  constructor(name){
    this.join = name;
    this.showData();
  }
  showData(){
    console.log(this);
  }
}

new dataModel('school');
```
위의 코드를 실행해보자. showData에 있는 this는 dataModel을 가리키고 있다. 
this가 어떻게 바인딩 되는지 쉽고 정확하게 알기위해서는 무엇으로 호출 되는지 파악하면된다.
함수로 호출되면 this는 window로 메서드로 호출되면 this는 호출한 주체로 바인딩된다.

> 함수로 호출되면 this는 window로 메서드로 호출되면 this는 호출한 주체로 바인딩된다.

이러한 문제를 해결하기 위해 this 바인딩을 우회하는 방법이 중요하다 .
ES6에서는 this가 전역객체를 바라보는 문제를 해결하고자, this를 바인딩하지 않는 화살표 함수가 생성되었다.  
이에따라 앞서 설명한 this가 잘못 바인딩 되는 문제를 해결 할 수 있게 된다.  

```html
<body> </body>
```

```javascript
let data = [
  {
    name : "changsun",
    age : 28,
  },
  {
    name : "sugin",
    age : 28,
  },
  {
    name : "man",
    age : 31,
  },
]

class dataModel {
  constructor(join){
    this.data = data;
    this.join = join;
    this.self = this;
    this.buildUI(); 
  }
  
  buildUI(){
    this.body = document.querySelector('body');
    this.showData();
  }
  showData(){
    let dom = []; 
    this.data.forEach( (ele, idx) => {
      let { join } = this.self;
      dom.push( `
        <div> 소속 : ${join} </div>
        <div> 이름 : ${ele.name} </div>
        <div> 나이 : ${ele.age} </div> <br>
      `)
    })
    this.body.innerHTML = dom.join('');
  }
}

new dataModel('school');
```

