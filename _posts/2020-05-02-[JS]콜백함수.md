---
title: "[Git] 콜백함수"
last_modified_at: 2020-04-11
share: true
related: false
categories:
  - javascript
tags:
  - javascript
  - callback
---

## 콜백 함수

> 다른 코드의 인자로 넘겨주는 함수

콜백함수는 다른 코드의 인자로 넘겨주는, 함수 즉 매개변수로 넘겨진 함수이다.  
다른 코드의 인자로 변수가 아닌 함수가 넘어간다는 부분이 이해하기 쉽지 않다. 
js는 변수에 함수를 할당할 수 있다. 쉽게 앞서 설명한 함수 함수 표현식을 떠올려보자. 

```javascript
let b = function() {console.log('b')};
```

결국 콜백 함수는 어떠한 매개변수 값으로 함수가 전달 될때. 그 함수를 콜백 함수라 한다. 


### 콜백함수의 의미

콜백함수가 왜 필요할까? 콜백함수가 가지는 의미에 대해 간단하게 알아보자. 

call(부르다) + back(되돌아오다)의 함성어인 콜백함수는 문자 그대로의 의미를 가진다. 
함수를 부른 곳을 다시 되돌아와서 코드를 실행하게 된다. 어떤 함수 X를 호출하면서 특정 조건일 때 
Y함수(콜백함수)를 실행 하고 호출한 지점인 함수 X로 돌아가 실행한다. 즉 Y함수는 X함수에 에 `종속적`이며, 
X함수는 Y함수의 `제어권`을 가지고 있다.  

간단한 예시로 확인해보자 

```javascript
var count1 = 0;
var timer = setInterval( () => {
  console.log(count1);
  if(++count1 > 4) clearInterval(timer);
}, 300);

실행결과 
0
1
2
3

 1. 변수 count1을 선언하고 0을 할당한다. 
 2. timer에는 setInterval()의 id값이 담긴다. 
 3. setInterval()함수가 0.3초마다 익명함수를 실행한다.  
 4. 익명함수는 count1의 값을 1씩 증가한다. setInterval()로 돌아간다.  
 4. count1의 값이 4보다 커지면 clearInterval()을 호출하여 timer를 종료한다.  
```
### 콜백함수의 this 바인딩

콜백 함수는 함수이다. 어떤 객체의 메서드로 호출되더라도 함수로써 호출된다. 
이에따라사 콜백 함수는 this는 window 객체를 바라보게 된다. 코드로 자세히 알아보자.  

```javascript
var obj = {
  vals: [1,2,3],
  logValues: function(v,i) {
    console.log(this,v,i);
  }
}
// 메서드로써 호출 => this : obj 
obj.logValues(1,2); 
// 콜백함수로써 호출 => this : window
obj.vals.forEach(obj.logValues);
```

즉 콜백 함수는 함수로 호출되기 때문에, this가 window객체를 바라본다는 문제가 있다.
이러한 문제를 해결하고자. this 바인딩을 우회 할 수 있어야한다. [this 바인딩](https://github.com/ckdtjs505/jsCoreStudy/blob/master/this.md)

### 콜백함수 this 우회 

1. 먼저 전통적인 방법인 변수 활용한 this를 우회

```javascript
var obj = {
  name: "sonia",
  getName: function() {
    var self = this;
    //익명함수를 선언과 동시에 반환 
    return function (){
      console.log(self.name);
    }
  }
}

var callback = obj.getName();
setTimeout( callback, 300);
```
보는거와같이 굳이 self 변수를 선언하고 this를 할당하는 모든 과정이 번거로워보인다. 
조금만 더 생각해보면, 위의 코드는 굉장히 불필요한 부분이 많이 들어갔다. 
왜냐하면 this를 사용하지 않고서도 유저의 이름을 가져올 수 있다.  

```javascript
var obj = {
  name: "sonia",
  getName: function() {
      console.log(obj.name);
  }
}

var callback = obj.getName();
setTimeout( callback, 300);
```
하지만 이코드 또한 약간에 문제가 있다. this를 사용하지 않다보니, this를 다양한 상황에서 재활용 할 수 없게 되었다.
어떻게 재활용이 되는지에 대해 먼저 알아보자. 첫번째 예시의 코드에서 this를 재활용해보자 

```javascript
var obj = {
  name: "sonia",
  getName: function() {
    var self = this;
    //익명함수를 선언과 동시에 반환 
    return function (){
      console.log(self.name);
    }
  }
}

var callback = obj.getName();
setTimeout( callback, 300);

var obj2 = {
  name: "stark",
  getName: obj.getName
}

var callback2 = obj2.getName();
setTimeout( callback2, 300);


var obj3 = {
  name: "dk"
}

var callback3 = obj.getName.call(obj3);
setTimeout( callback3, 300);
```

이렇게 obj.getName함수가 재활용 될 수 있었다. 이에 반해, 두번째로 설명한 예제는 obj로 값을 지정했기 때문에
다른 객체를 바라볼수 있게 할 수 없다는 문제가 있다. 이에따라 전통적인 방법의 this 우회가 많이 사용되고 있다.

### 2) bind 함수를 이용한 this 우회 

전통적인 방법의 this 우회의 경우 어쩔수 없이 새로운 변수를 생성하고 할당해야한다는 아쉬움이 있었다.  
이러한 문제를 해결해 보고자 ES5에서 사용하는 bind 함수가 등장하게 된다.  

```javascript
var obj = {
  name: "sonia",
  getName: function() {
    console.log(this.name);      
  }
}
setTimeout( obj.getName.bind(obj), 300 );

var obj2 = { name : "sujin"};
setTimeout( obj.getName.bind(obj2), 300);
```

이러한 방식으로 this를 바인딩할 수 있게 된다.  

### 3) arrow func을 활용한 this 우회 

ES6가 호환되는 환경이라면 arrow func으로도 우회할 수 있으므로 우회해보자  

```javascirpt
var obj = {
  name: "sonia",
  getName: function() {
    // 화살표함수를 선언과 동시에 반환 
    return () => console.log(this.name);      
  }
}

var callback = obj.getName();
setTimeout( callback, 300);
```
코드가 굉장히 깔끔해 보인다. 화살표함수는 this 바인딩 자체가 없으므로 우회를 하지 않아.  
확실히 코드가 깔끔해 보인다. ㅎㅎ 
