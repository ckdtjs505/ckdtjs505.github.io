---
layout: post
title: '[알고리즘/프로그래머스/JS] 베스트 엘범'
date: 2021-01-03
tags: javascript  
comments: true
share: true
related: false
---

### 목표
* 베스트 엘범 문제 풀이  
* 문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/42579?language=javascript

### 내용 
1. 속한 노래가 가장 많이 재생된 장르를 수록합니다.
2. 장르 내에서 많이 재생된 노래를 먼저 수록합니다.
3. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.

### 문제 풀이

> 최대한 변수를 많이 선언하지 않는 방향으로 풀이 

1. 데이터 추상화



... 미완 ...

* 회사 일이 바쁜 관계로 오늘은 알고리즘을 제대로 하지 못했다. 내일 다시 작업해서 올리자 

### 결론
* 데이터를 가공하는데 reduce, map 이 효율적으로 사용되니 이 두개의 함수의 사용범을 알고 익숙해질 필요가 있다. 

---

### 최초 연습 풀이 
1. 데이터 추상화
`genres`, `plays` 두개의 다른 배열로 값이 내려온다.   
이 두개의 배열을 합쳐 하나의 데이터로 만들어주자

```js
const songs = genres.map( (ele, idx) => {
    return { genre : ele , idx : idx, plays : plays[idx] } 
});
console.log( songs);

=>  실행 결과 
  [
    { genre: 'classic', idx: 0, plays: 500 },
    { genre: 'pop', idx: 1, plays: 600 },
    { genre: 'classic', idx: 2, plays: 150 },
    { genre: 'classic', idx: 3, plays: 800 },
    { genre: 'pop', idx: 4, plays: 2500 }
  ]
```

장르별 재생 횟수를 알아야 가장 많이 재생된 장르를 먼저 수록할수 있기 때문에 장르별 재생 횟수를 가진 데이터를 만들자. 

```js
// 장르 별 재생 횟수 데이터 
const genresPlays = genres.reduce((genresList, g, i) => {
    if (!genresList[g]) {
        genresList[g] = plays[i];
    } else {
        genresList[g] += plays[i];
    }
    return genresList;
}, {});
console.log(genresPlays)

=> 실행 결과
  { classic: 1450, pop: 3100 }
```