---
title: '[Js] 클로져'
last_modified_at: 2020-05-08
share: true
related: false
tags:
  - javascript
  - closure
---

클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. [`MDN`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures),
JS 대표 사이트인 MDN에서의 설명이다. 이해하기 어렵지만 천천히 이해해 보자. 먼저 어휘적 환경의 의미를 먼저 생각해보자. `어휘적 환경`은 영어로하면 `LexicalEnvironment`이다. `LexicalEnvironmnt`는 실행 컨텍스트에서 유효범위인 스코프가 결정되고, 스코프 체인이 가능하게 하는 역할을 한다고 배웠다. 즉 함수와 함수사이에서 벌어지는 유효범위가 또 존재하는 것으로 이해해도 좋다. 

### 클로저란? 

예시로 좀더 정확하게 이해해보자. 

```javascript
function outer() {
  function inner(){
    console.log(++a);
  }
  var a = 1;
  inner();
  console.log(a);
}
outer(); 

outer함수와 inner함수 사이의 유효 스코프가 결정된다.  
따라서 inner함수에서 a의 값이 선언되어 있지 않지만 
클로져에 의해 outer함수의 a에 접근하여 a의 값인 1을 출력한다.  
```

즉 내부함수에서 외부함수의 변수에 접근할 수 있는 것이 바로 클로저의 역할이다.

```javascript
function outer() {
  var a = 0;
  function inner(){
    console.log(++a);
  }
  return inner();
}
outer(); 
outer();

실행결과 
1
1

8번째줄 outer 함수를 실행하면서 변수 a에 0을 할당한다 
이후 inner 함수에서 outer 함수 변수 a에 접근하여 1을 증가한값인 1을 출력한다. 
9번째줄 또한 outer 함수를 새로 실행하면서 변수 a에 0을 할당한다.
이후 동일하게 inner 함수에서 outer 함수 변수 a에 접근하여 1을 증가한값인 1을 출력한다. 
```

outer 함수가 종료된 이후에 inner함수를 호출할수 없는 코드이다. 
어찌보면 너무 당연한 말이지만, 이런경우도 있을수 있다. 
어떤경우에는 outer 함수가 종료된 이후에도 inner 함수를 호출 할 수 있다.
코드로 살펴보자. 

```javascript
function outer() {
  var a = 0;
  function inner(){
    console.log(++a);
  }
  return inner;
}
var smallInner = outer(); 
smallInner();
smallInner();

실행결과
1
2

8번째 줄 outer 함수를 실행하면서 변수 a에 0을 할당하고 inner 함수를 반환한다.
smallInner에는 inner함수가 들어가게 된다. 
이후 9번째 줄 smallInner가 변수 a에 접근 후 1을 증가하여 1을 출력한다. 
이후 10번째 줄 smallInner가 변수 a에 접근 후 1을 증가하여 2을 출력한다.
```
 inner함수가 outer함수가 종료된 이후에도 outer함수의 변수에 접근할 수 있다는 점이 신기하다.
 이런 기능이 가능한 이유는 바로 가비지 컬렉터의 역할 때문인데, 가비지 컬렉터는 어떤 값을 참조하는
 값이 하나라도 있다면 그 값을 수집 대상에 포함시키지 않기 때문이다.

즉 정리하면 
> 클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우
> A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상을 말한다.

위의 예시만 봤을때 약간의 오해의 소지가 있다.
가장큰 오해의 소지로는 외부 변수를 참조하는 내부변수는 `return`한 경우에만 있다고 생각 한다.
`return` 없이도 클로저가 발생하는 다양한 경우를 예시로 확인해보자 

첫째 setInterval/setTiemout
```javascript
function outer () {
  var a = 0;
  var intarvalId = null;
  var inner = function(){
    if( a < 5)
      console.log(++a);
    else
      clearInterval(intarvalId);
  };
  intarvalId = setInterval(inner, 1000);
}
outer();

실행결과 
1
2
3
4
5

setInterval 함수의 첫번째 인자로 콜백함수인 inner 함수를 매개변수로 전달한다.
이때에도 클로저가 발생하여 외부함수에 a 변수를 찾고, 외부함수 outer에 a가 할당 되어 있으므로, 
a를 참조하여 실행한다. 
```

둘째 eventListenser
```javascript
function outer(){
  var count = 0;
  const button = document.createElement('button');
  button.innerHTML = "CLICK";
  button.addEventListener("click", function inner() {
    console.log(++count);
  })
  
  document.body.appendChild(button);
}

outer();
실행결과 
CLICK 버튼 클릭시 count 값 증가출력

button dom을 생성하여 이벤트를 생성한다. 이벤트 실행시 콜백함수로 inner함수를 실행하게된다.
inner함수는 count값을 증가후 console에 출력하는데, 이때 클로저가 발생하여 outer count에 접근하여
count값을 증가하여 출력할 수 있게 된다. 
```

> 이렇게 클로저는 return이라는 특수한 상황에만 발생하는 것이 아니다. 


### 클로저와 메모리 관리
지금까지 클로저에 대해 간단하게 알아보았다. 클로저로 실행이 끝난 외부 함수의 변수에 접근 할 수 있수 있다 배웠다.
좀더 정확하게는 `가비지 컬렉터`가 어떤 값을 하나라도 참조하는 값이 있다면, 그 값은 수집 대상에 포함시키지 않게 된다. 
이에따라 클로저를 사용하게 될수록 메모리 누수가 발생하게 된다. 이런 이유로 클로저 사용을 조심해야한다는 사람들도 있다.

이러한 메모리 누수를 해결하기 위한 간단한 관리방법을 알아보자. 
관리방법이라고 하니 엄청나 보이지만, 아주 간단하다. 클로저를 통해 접근한 지역변수를 다 사용했다면 메모리를 소모하지 않도록
참조 카운트를 0으로 만들면 된다. 그러면 언젠가 `가비지 컬렉터`가 수거해 갈 것이고, 소모되었던 메모리는 회수되게 된다. 
참조 카운트를 0으로 만드는 방법으로 `참조형`이 아닌 `기본형`데이터(null, undefined)를 할당하게된다. 
참조 카운트에 `기본형`데이터를 넣는다는것은 이전에 참조하고 있던 함수를 끊는다는 것과 동일한 의미를 가진다. 

앞에서 배웠던 예시들에 메모리 해제 코드를 추가해보자. 

```javascript
function outer() {
  var a = 0;
  function inner(){
    console.log(++a);
  }
  return inner;
}
var smallInner = outer(); 
smallInner();
smallInner();
// smallInner에 outer함수의 inner참조를 끊는다.  
smallInner = null;

function outer () {
  var a = 0;
  var intarvalId = null;
  var inner = function(){
    if( a < 5){
      console.log(++a);      
    }
    else{
      clearInterval(intarvalId);
      // inner 변수의 익명함수 참조를 끊는다. 
      inner = null;
    }
  };
  intarvalId = setInterval(inner, 1000);
}
outer();

function outer(){
  var count = 0;
  const button = document.createElement('button');
  button.innerHTML = "CLICK";
  button.addEventListener("click", function inner() {
    console.log(++count);
  })
  // 카운트의 제한이 없으므로 실별자의 참조를 끊을 수 없다.
  document.body.appendChild(button);
}
```

### 클로저의 활용 사례
지금까지 클로저에 대하 알아보았다. 클로저는 특정 조건에서 변수가 사라지지 않는 현상으로 배웠다. 그리고 변수가 사라지지
않아 메모리 누수가 있어 이러한 메모리 누수를 해결하는 방법 또한 알아보았다. 지금 부터는 배운 내용을 활용해보자.

첫째. 콜백 함수 내부에서 외부 데이터를 사용할때
둘째. 접근 권한 제어
셋째. 부분 적용 함수
넷째. 커링 함수 



## 함수 이해하기
[`함수객체`](https://meetup.toast.com/posts/118), [`함수호출`](https://meetup.toast.com/posts/123)  

### 함수 선언식과 함수 표현식
함수 선언식의 경우 반드시 함수명이 정의 되어 있어야 한다.  
함수명을 정의한 함수 표현식을 `기명 함수 표현식`, 정의하지 않은 것을 `익명함수 표현식`이라고 한다. 

```javascript 
// 함수 선언식 
function a() { console.log('a'); } 

// 함수 표현식 - 익명 함수 표현식
let b = function () { console.log('b'); }

// 함수 표현식 - 기명 함수 표현식
let c = fucntion d () {console.log('c,b')}
```
