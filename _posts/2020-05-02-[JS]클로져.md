---
title: '[Js] 클로져'
last_modified_at: 2020-05-08
share: true
related: false
tags:
  - javascript
  - closure
---

클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. [`MDN`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures),
JS 대표 사이트인 MDN에서의 설명이다. 이해하기 어렵지만 천천히 이해해 보자. 먼저 어휘적 환경의 의미를 먼저 생각해보자. `어휘적 환경`은 영어로하면 `LexicalEnvironment`이다. `LexicalEnvironmnt`는 실행 컨텍스트에서 유효범위인 스코프가 결정되고, 스코프 체인이 가능하게 하는 역할을 한다고 배웠다. 즉 함수와 함수사이에서 벌어지는 유효범위가 또 존재하는 것으로 이해해도 좋다. 

### 클로저란? 

예시로 좀더 정확하게 이해해보자. 

```javascript
function outer() {
  function inner(){
    console.log(++a);
  }
  var a = 1;
  inner();
  console.log(a);
}
outer(); 

outer함수와 inner함수 사이의 유효 스코프가 결정된다.  
따라서 inner함수에서 a의 값이 선언되어 있지 않지만 
클로져에 의해 outer함수의 a에 접근하여 a의 값인 1을 출력한다.  
```

즉 내부함수에서 외부함수의 변수에 접근할 수 있는 것이 바로 클로저의 역할이다.

```javascript
function outer() {
  var a = 0;
  function inner(){
    console.log(++a);
  }
  return inner();
}
outer(); 
outer();

실행결과 
1
1

8번째줄 outer 함수를 실행하면서 변수 a에 0을 할당한다 
이후 inner 함수에서 outer 함수 변수 a에 접근하여 1을 증가한값인 1을 출력한다. 
9번째줄 또한 outer 함수를 새로 실행하면서 변수 a에 0을 할당한다.
이후 동일하게 inner 함수에서 outer 함수 변수 a에 접근하여 1을 증가한값인 1을 출력한다. 
```

outer 함수가 종료된 이후에 inner함수를 호출할수 없는 코드이다. 
어찌보면 너무 당연한 말이지만, 이런경우도 있을수 있다. 
어떤경우에는 outer 함수가 종료된 이후에도 inner 함수를 호출 할 수 있다.
코드로 살펴보자. 

```javascript
function outer() {
  var a = 0;
  function inner(){
    console.log(++a);
  }
  return inner;
}
var smallInner = outer(); 
smallInner();
smallInner();

실행결과
1
2

8번째 줄 outer 함수를 실행하면서 변수 a에 0을 할당하고 inner 함수를 반환한다.
smallInner에는 inner함수가 들어가게 된다. 
이후 9번째 줄 smallInner가 변수 a에 접근 후 1을 증가하여 1을 출력한다. 
이후 10번째 줄 smallInner가 변수 a에 접근 후 1을 증가하여 2을 출력한다.
```
 inner함수가 outer함수가 종료된 이후에도 outer함수의 변수에 접근할 수 있다는 점이 신기하다.
 이런 기능이 가능한 이유는 바로 가비지 컬렉터의 역할 때문인데, 가비지 컬렉터는 어떤 값을 참조하는
 값이 하나라도 있다면 그 값을 수집 대상에 포함시키지 않기 때문이다.

즉 정리하면 
> 클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우
> A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상을 말한다.

위의 예시만 봤을때 약간의 오해의 소지가 있다.
가장큰 오해의 소지로는 외부 변수를 참조하는 내부변수는 `return`한 경우에만 있다고 생각 한다.
`return` 없이도 클로저가 발생하는 다양한 경우를 예시로 확인해보자 

첫째 setInterval/setTiemout
```javascript
function outer () {
  var a = 0;
  var intarvalId = null;
  var inner = function(){
    if( a < 5)
      console.log(++a);
    else
      clearInterval(intarvalId);
  };
  intarvalId = setInterval(inner, 1000);
}
outer();

실행결과 
1
2
3
4
5

setInterval 함수의 첫번째 인자로 콜백함수인 inner 함수를 매개변수로 전달한다.
이때에도 클로저가 발생하여 외부함수에 a 변수를 찾고, 외부함수 outer에 a가 할당 되어 있으므로, 
a를 참조하여 실행한다. 
```

둘째 eventListenser
```javascript
function outer(){
  var count = 0;
  const button = document.createElement('button');
  button.innerHTML = "CLICK";
  button.addEventListener("click", function inner() {
    console.log(++count);
  })
  
  document.body.appendChild(button);
}

outer();
실행결과 
CLICK 버튼 클릭시 count 값 증가출력

button dom을 생성하여 이벤트를 생성한다. 이벤트 실행시 콜백함수로 inner함수를 실행하게된다.
inner함수는 count값을 증가후 console에 출력하는데, 이때 클로저가 발생하여 outer count에 접근하여
count값을 증가하여 출력할 수 있게 된다. 
```

> 이렇게 클로저는 return이라는 특수한 상황에만 발생하는 것이 아니다. 
> 항상 클로저가 어떻게 동작하는지 분석하는 습관이 중요하다 


### 클로저와 메모리 관리


## 함수 이해하기
[`함수객체`](https://meetup.toast.com/posts/118), [`함수호출`](https://meetup.toast.com/posts/123)  

### 함수 선언식과 함수 표현식
함수 선언식의 경우 반드시 함수명이 정의 되어 있어야 한다.  
함수명을 정의한 함수 표현식을 `기명 함수 표현식`, 정의하지 않은 것을 `익명함수 표현식`이라고 한다. 

```javascript 
// 함수 선언식 
function a() { console.log('a'); } 

// 함수 표현식 - 익명 함수 표현식
let b = function () { console.log('b'); }

// 함수 표현식 - 기명 함수 표현식
let c = fucntion d () {console.log('c,b')}
```
